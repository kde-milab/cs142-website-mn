
<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>CS142 Project 7: Sessions and Input</title>
    <meta name="description" content="Web Applications course at Stanford University">

    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/main.css">

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>

    <script src="js/jquery.min.js"></script> 
    <script src="js/bootstrap.min.js"></script>

</head>


  <body>

    <header>

  <nav class="navbar">
    <div class="container">

      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">CS142 (Spring 2023)</a>
      </div>

      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav navbar-right">
          
            
            
            <li class="">
              <a href="index.html">Home</a> 
            </li>
          
            
            
            <li class="">
              <a href="info.html">Class Info</a> 
            </li>
          
            
            
            <li class="">
              <a href="lectures.html">Lectures</a> 
            </li>
          
            
            
            <li class="nav-active">
              <a href="projects.html">Projects</a> 
            </li>
          
            
            
            <li class="">
              <a href="staff.html">Staff</a> 
            </li>
          
        </ul>
      </div>
      
    </div>
  </nav>
</header>


    

        <main><div class="container">

  <h1>CS142 Төсөл 7: Хурал ба оролт</h1>

  <h4 class="text-muted">
    Хугацаа: 2023 оны 6-р сарын 1-ний Пүрэв гарагийн 23:59 цагт
  </h4>

  <p>
    Энэ төсөлд та хэрэглэгчдэд нэвтрэх, зураг дээр сэтгэгдэл бичих, шинэ зураг байршуулан нэмснээр Төсөл 6 дээрх ажлаа өргөтгөх болно. 
    Эдгээр шинэ функцийн нэмэлтүүд нь бүрэн стек  <strong>full stack</strong> тул та front end (React програм) болон backend (Node вэб 
    сервер болон MongoDB мэдээллийн сан) 
    хоёуланг нь өөрчлөх шаардлагатай гэдгийг анхаарна уу.
  </p>

  <section>
    <h3 class="left-border">Тохиргоо</h3>
    <p>
      Та өөрийн системд MongoDB болон Node.js суулгасан байх ёстой. 
      Хэрвээ байхгүй бол <a href="install.html">суулгах заавар </a> дагана уу.
    </p>
    <p>
      Төсөл 6-н нэгэн адил та өмнөх төслийн директорын (<code>project6</code>) файлуудыг
      <code>project7</code> нэртэй шинэ хэсэг рүү нь хуулж эхэлнэ (<b> <code>.babelrc</code> болон
        <code>.eslintrc.json</code> files</b> оруулаад ямар ч далд байгаа файлуудыг шилжүүлсэн эсэхийг шалгаарай). Энэ <a href="downloads/project7.zip"> zip file</a>-ийн агуулгуудыг
      <code>project7</code> файл руу задлана. Энэ зип файл нь хэд хэдэн шинэ файл нэмэх болно. <code>project7</code> файл дээр энэ төслийн бүх ажлаа хийгээрэй.
      
    </p>
    <p>
      Энэ даалгаврыг хийхийн тулд та хэдэн шинэ
      <code>node_modules</code> авчирч, тэдгээрийг вэб сервер
      болон React програмдаа нэмэх хэрэгтэй болно. Модуль бүрд дараах командыг ашиглана уу
    <pre>npm install --save &lt;module&gt;</pre> 
    Энэ нь <code>&lt;module&gt;</code> нэртэй модулийг таны <code>node_modules</code>
    лавлах(directory) руу татаж, <code>package.json</code> файлд хамаарлыг нэмнэ.
    Модулийг вэб сервертээ нэмэхийн тулд <code>require</code> функцийг ашиглана уу.
    </p>
    Та node модулиуддаа дараах Express дундын(middleware)
    модулиудыг татах шаардлагатай болно
    <ul>
      <li><a href="https://github.com/expressjs/session"><code>express-session</code></a>
        - Экспресс сесс нь танд зориулж сессийн удирдлагыг зохицуулахаас илүү Express дундын давхарга
        (middleware) болдог юм. Үүнийг лекц дээр тайлбарласан.
      </li>

      <li><a href="https://github.com/expressjs/body-parser"><code>body-parser</code></a>
        -
        <code>body-parser</code> нь HTTP хүсэлтийн биетийг задлан шинжлэхэд 
        зориулагдсан Express дундын давхарга юм. Та үүнийг манай серверийн API-д ашигладаг JSON кодлогдсон POST 
        хүсэлтийн биетүүдийг задлан шинжлэхэд ашиглаж болно. Жишээлбэл, хэрэв 
        та <code>parameter_name</code> бүхий JSON объектоос бүрдэх 
        биеттэй хүсэлтийг дамжуулбал энэ нь Экспресс хүсэлт зохицуулагч дээр
        <code>request.body.parameter_name</code> хэлбэрээр харагдана.
      </li>

      <li><a href="https://www.npmjs.com/package/multer#readme"><code>multer</code></a>
        -
        <code>multer</code> нь бидний зураг байршуулахад 
        шаардлагатай олон хэсэгтэй маягтуудыг боловсруулах чадвартай өөр нэг Express дунд програмын бие задлагч юм.

      </li>
    </ul>
    <p>
      Ихэнх систем дээр дараах тушаалууд дээрх модулиудыг татах ёстой:

    <pre>
npm install --save express-session
npm install --save body-parser
npm install --save multer
</pre>
    </p>
    <p>
      Эдгээр шаардлагатай мэдэгдлүүдийг ашиглан <code>webServer.js</code> -д нэмнэ үү:
    <pre>
const session = require("express-session");
const bodyParser = require("body-parser");
const multer = require("multer");
</pre>
    </p>
    <p>
      Эцэст нь та дараах байдлаар Экспресс <code>use</code> илэрхийлэхийн тулд <code>express-session</code> болон
      <code>body-parser</code>
      дунд программыг нэмэх хэрэгтэй:
    <pre>
app.use(session({secret: "secretKey", resave: false, saveUninitialized: false}));
app.use(bodyParser.json());
</pre>
    Энд <code>"secretKey"</code> нь сесс күүкийг криптографийн аргаар хамгаалахад 
    ашигладаг нууц юм. Бид зураг байршуулах кодонд <code>multer</code> дунд 
    програмыг(middleware) ашиглах болно.
    </p>
    <p>
      Хэрэв та 6-р төслийн 2-р асуудлыг шийдвэрлэсэн бол загваруудыг татахын тулд  <code>axios</code>
      -ийг ашиглах хэрэгтэй. Хэрэв та Төсөл 6-д хэрэгжүүлээгүй бол илүү дэлгэрэнгүй мэдээллийг  <code>axios</code> <a href="https://github.com/axios/axios">documentation</a>
      -ээс харна уу.
    </p>
    <p>
      Өмнөх даалгаврын нэгэн адил бид серверийн API-ийн Mocha тестийг өгдөг бөгөөд ингэснээр та урд талын кодыг 
      хэрэгжүүлэхээсээ өмнө арын хэсэгтээ итгэлтэй байх болно. <strong>Энэ сайхан байдлын хариуд та бидний 
      тодорхойлсон серверийн API-г хэрэгжүүлэхээр хязгаарлагдах болно. Энэ нь 
      таны кодыг илгээхээсээ өмнө бидний өгсөн тестийг давсан эсэхийг шалгана гэсэн үг юм. 
      Дэлгэрэнгүй мэдээллийг доорх Туршилтын хэсгээс үзнэ үү.</strong> Хэрэв та Төслийн 6 
      Нэмэлт Кредитийг хийж байхдаа API-ээ сунгасан бол 
      өргөтгөсөн API-ээ зохицуулах тестүүдийг нөхөх шаардлагатай болно. Хэрэв та энэ 
      төсөлд нэмэлт зээл олгохоор шийдсэн бол нэмэлт шалгалтыг давах шаардлагатай болно.
    </p>
    <p>
      Өмнөх төслийн нэгэн адил та MongoDB instance-ээ эхлүүлэх хэрэгтэй болно. 
      MongoDB-г дараах тушаалыг ажиллуулж эхлүүлнэ үү:
    <pre>
mongod (яг аргументууд нь мэдээллийн санг хаана байршуулснаас хамаарна)
</pre>
тушаалыг ажиллуулж зургийн програмын өгөгдлийг харна уу:
    <pre>node loadDatabase.js</pre>
    Төслийн 7-д түгээдэг энэхүү тушаалын хувилбар нь 
    хэрэглэгчийн объектыг <code>login_name</code> (тэдний овгийн нэрний <code>last_name</code> жижиг хувилбар
    ) болон <code>"weak"</code> нууц үгээр ачаалдаг болохыг анхаарна уу. Эдгээр 
    шинж чанарууд нь зөвхөн схемд талбаруудыг нэмсний дараа <code>loadDatabase.js</code> -г ажиллуулах үед 
    гарч ирнэ (1-р асуудалд).
    </p>
  </section>

  <section>
    <h3 class="left-border">Node.js вэб серверийг эхлүүлэх нь
    </h3>
    <p>
      Мэдээллийн санг ажиллуулсны дараа вэб серверээ эхлүүлэх хэрэгтэй болно. 
      Хэдийгээр үүнийг өмнөх даалгавруудтай ижил тушаалаар (жишээ нь, <code>node webServer.js</code>), хийж болох боловч 
      <code>webServer.js</code> -г өөрчлөх үед автоматаар дахин эхлүүлэх програм ашиглан вэб 
      серверийг эхлүүлэх нь илүү тохиромжтой. Үгүй бол та хийсэн өөрчлөлт бүрийн дараа вэб серверээ 
      дахин эхлүүлэх эсвэл дахин эхлүүлэхээ мартсан үед таны өөрчлөлт яагаад ажиллахгүй болсныг 
      гайхан цаг хугацаа зарцуулах болно.
    </p>
    Нөгөө тушаал
    <pre>npm install -g nodemon</pre>
    автоматаар дахин ачаалдаг <a href="http://nodemon.io">nodemon</a> нэртэй 
    программыг суулгах болно (та <code>sudo</code> командыг ашиглан ажиллуулах хэрэгтэй байж магадгүй). Note that the
    <code>-g</code> туг нь програмыг global байдлаар суулгадаг тул та хаана ч 
    ажиллуулах боломжтой гэдгийг анхаарна уу. <code>project7</code> лавлахын тушаалаар вэб серверээ эхлүүлнэ үү :
    <div class="code">
      <pre>nodemon webServer.js</pre>
    </div>
    Энэ тушаал нь вэб серверийг ажиллуулж, <code>webServer.js</code> файл өөрчлөгдөх 
    бүрт дахин эхлүүлэх болно. Хэрэв танд Node-ийг гарахад хүргэдэг алдаа (жишээ нь, 
    JavaScript синтакс алдаа) гарж байвал nodemon таныг <code>webServer.js</code> файлыг өөрчлөх 
    хүртэл хүлээж, дараа нь дахин эхлүүлэхийг оролдоно. Хэрэв та файлыг өөрчлөхгүйгээр вэб 
    серверийг дахин эхлүүлэхийг хүсвэл nodemon командын  <code>rs</code> гэсэн хоёр тэмдэгт командыг 
    бичиж гараар дахин эхлүүлж болно. Та Node.js кодоос бүртгэлийн мессежүүдийг (logging messages) харахын тулд үүнийг өөрийн цонхонд ажиллуулах гэж байх болно.

    </p>
    <p>
      Төсөл 7-ын шинэ файлуудаар Photo Share програмаа 
      шинэчилж, мэдээллийн сан болон вэб серверийг ажиллуулсны дараа 
      даалгавраа үргэлжлүүлэхийн өмнө програм ажиллаж байгаа эсэхийг шалгаарай.
    </p>
  </section>


  <section>
    <h3 class="left-border">Асуудал 1: Энгийн нэвтрэлт (15 оноо)
    </h3>
    <p>
      Хэрэглэгч нэвтэрч байгаа гэсэн ойлголттой болохын тулд зургийн аппликейшнээ өргөтгөнө үү. 
      Хэрэв хэрэглэгч нэвтэрсэн бол хэрэгслийн самбарт "Hi &lt;firstname&gt;" гэсэн жижиг мессеж байх ёстой бөгөөд &lt;firstname&gt;
      нь нэвтэрсэн хэрэглэгчийн нэр юм. Хэрэгслийн самбар нь хэрэглэгчийг гаргах "Logout" товчийг агуулсан байх ёстой.
    </p>
    <p>
      Хэрэв нэвтэрсэн хэрэглэгч байхгүй бол хэрэглүүрийн (toolbar) мөрөнд "Please Login" 
      гарч ирэх бөгөөд таны програмын үндсэн хэсэгт <code>LoginRegister</code> нэртэй шинэ 
      харагдац (view) гарч ирнэ. <code>LoginRegister</code>  харагдац нь хэрэглэгчийг нэвтрэх арга замыг зааж өгөх ёстой бөгөөд доорх 4-р 
      асуудлын нэг хэсэг болгон шинэ хэрэглэгчээр бүртгүүлнэ үү. Өөр харагдац руу шилжих бүх оролдлого (жишээ нь, гүнзгий холбоосууд) нь 
      хэрэглэгч нэвтэрч ороогүй тохиолдолд дэлгэцийг <code>LoginRegister</code>
      харагдац руу шилжүүлэхэд хүргэнэ . (Хэрэв та үүнийг хэрхэн хэрэгжүүлэхээ 
      мэдэхгүй байгаа бол зөвлөмж хэсгийг үзнэ үү.) Үүнээс гадна, Хэрэв одоогийн хэрэглэгч нэвтрээгүй бол зүүн 
      талд байгаа хэрэглэгчийн жагсаалтыг бөглөх ёсгүй. (401 (Unauthorized) статусыг 
      буцаахын тулд серверийн төгсгөлийн цэгүүдийг өөрчлөх тухай доорх хэсгийг үзнэ үү).

    </p>
    <p>
      Хэрэглэгч амжилттай нэвтэрсэн үед харагдах байдал нь хэрэглэгчийн дэлгэрэнгүй 
      мэдээллийг харуулах руу шилжих ёстой. Хэрэв хэрэглэгчийн нэвтрэлт амжилтгүй болвол (жишээ нь,
      <code>login_name</code>-тэй хэрэглэгч байхгүй) харагдац нь зохих алдааны мэдэгдлийг мэдээлэх 
      бөгөөд хэрэглэгч дахин оролдох боломжийг олгох юм.
    </p>
    <p>
      Нэвтэрсэн хэрэглэгчдийн фото апп-ийн үйл ажиллагааг дэмжихийн тулд арын хэсгийн хэрэгжүүлэлтээ 
      өргөтгөх хэрэгтэй. Энэ өөрчлөлтийг хийхдээ та өгөгдлийн сангийн схем болон вэб серверийн API-г хоёуланг 
      нь өөрчлөх шаардлагатай болно.
    </p>
    <p>
      <code>User</code> дээр шинэ хэсэг (property) <code>login_name</code> нэмэхийн 
      тулд Mongoose схемийг өргөтгөнө үү.Энэ хэсэг нь хэрэглэгчийн нэвтрэх үед бичих 
      үед танигчийг (тэдний "нэвтрэх нэр") агуулсан тэмдэгт мөр юм.

    <p>Вэб серверийн API-г өөрчлөн хэрэглэгчийг нэвтрэх, гаргахын тулд 2 шинэ 
      REST API дуудлагыг хийх хэрэгтэй. Өмнөх даалгаврын нэгэн адил бид загварөн өгөгдлийг 
      дамжуулахын тулд JSON кодлогдсон биетэй HTTP хүсэлтийг ашиглах болно. API нь POST хүсэлтийг 
      дараах зорилгоор ашигладаг:</p>
    <ul>
      <li><code>/admin/login</code> - Зургийн програмын <code>LoginRegister</code> харагдац нь 
        хэрэглэгч рүү нэвтрэх боломжийг олгодог. POST хүсэлттэй JSON-кодлогдсон хэсэг нь property 
        <code>login_name</code>
        (одоохондоо нууц үг байхгүй) агуулсан байх ёстой бөгөөд таны апп-д нэвтэрсэн хэрэглэгчдэд шаардлагатай 
        мэдээллийг агуулсан байх ёстой. Нэвтрэх амжилтгүй болсон тохиолдолд (жишээ нь , <code>login_name</code> хүчинтэй бүртгэл биш) 400 (муу хүсэлт) 
        HTTP статусыг буцаана. Хүсэлтийн бие дэх параметрт
        <code>request.body.parameter_name</code> ашиглан ханддаг.Нэвтрэх бүртгэлийн зохицуулагч нь өгөгдсөн
        <code>login_name</code>-тэй хэрэглэгч байгаа эсэхийг шалгах ёстой гэдгийг анхаарна уу.  Хэрэв тийм бол энэ нь хэрэглэгч нэвтэрсэн 
        эсэхийг мэдэх шаардлагатай бусад хүсэлт боловсруулагчаар шалгах боломжтой зарим мэдээллийг Экспресс сессэд хадгалдаг.
        <code>POST /admin/login</code> -ийн буцаах хэсэг нь таны нэвтэрсэн хэрэглэгчийн шинж чанар буюу 
        вэб програмын хэрэгцээ байх ёстой.  Манай шалгах хэсгүүдэд <code>_id</code> property шаарддаг боловч та бусад 
        хэрэглэгчийн объектын шинж чанаруудыг оруулж болно. 4-р асуудалд нэмсэн зүйлээс болж хэрэглэгчийн объектыг бүхэлд нь буцаах нь дэмий болдог.
      </li>
      <li><code>/admin/logout</code> -Энэ URL руу хоосон биетэй POST хүсэлт нь сессэд (session) хадгалагдсан мэдээллийг устгаснаар 
        хэрэглэгч оролтоос гарах болно. Хэрэглэгч одоогоор нэвтрээгүй байгаа үед HTTP статус 400 (муу хүсэлт) буцаж ирэх ёстой.</li>
    </ul>
    <p>
      Нэвтрэх/гаралтыг зохицуулахын тулд вэб серверийг шинэчлэх нэг хэсэг болгон 
      хэрэв сессийн төлөв нь хэрэглэгч нэвтрээгүй гэвэл чи бүх хүсэлтүүдээ (<code>/admin/login</code> болон
      <code>/admin/logout</code>-аас бусад) 401
      (Unauthorized) статусыг арилгахын тулд дахин шинэчлэх хэрэгтэй.
  </section>

  <section>
    <h3 class="left-border">Асуудал 2: Шинэ сэтгэгдэл (15 оноо) </h3>
    <p>
      Хэрэглэгчийн нэвтрэлтийг хэрэгжүүлсний дараа дараагийн алхам бол зураг дээр 
      сэтгэгдэл нэмэх боломжийг хэрэгжүүлэх явдал юм. Зургийн тайлбарыг харуулах 
      зургийн дэлгэрэнгүй харагдац дээр одоо нэвтэрсэн хэрэглэгчид зурган дээрээ 
      сэтгэгдэл нэмэх боломжийг нэмнэ үү. Та энэ функцийн хэрэглэгчийн интерфэйсийг 
      (жишээ нь, попап харилцах цонх, оруулах талбар гэх мэт) зохион бүтээх хэрэгтэй. 
      Үүнийг хэрхэн ашиглах, ямар зургийн тухай сэтгэгдэл бичих нь тодорхой байх ёстой. 
      Зургийн дэлгэц болон түүний тайлбарыг шинээр нэмсэн сэтгэгдлийг тусгахын тулд нэн 
      даруй шинэчлэх шаардлагатай.

    </p>
    <p>
      Арын талын дэмжлэгийн хувьд вэб серверийн API-г дараах 
      HTTP POST API-аар өргөтгөнө үү:
    <ul>
      <li><code>/commentsOfPhoto/:photo_id</code> - ID нь <code>photo_id</code> гэсэн зурган 
        дээр сэтгэгдэл нэмнэ. POST хүсэлтийн үндсэн хэсэг нь тайлбарын текстийг агуулсан нэг property
        тайлбар бүхий <code>comment</code>-ийг JSON кодлогдсон бие байлгах ёстой.  Зураг дээр 
        үүсгэсэн сэтгэгдэл бичих объект нь нэвтэрсэн хэрэглэгчийн таниулбар болон сэтгэгдэл 
        үүсгэсэн цагийг агуулсан байх ёстой. Таны хэрэгжилт 400 статустай (Bad request) хоосон сэтгэгдэл бичих боломжгүй байлгах ёстой.
        </li>
    </ul>
    </p>
  </section>

  <section>
    <h3 class="left-border">Aсуудал 3: Зураг байршуулах (15 оноо)</h3>
    <p>
      Хэрэглэгчдэд шинэ зураг нэмэх боломжийг бий болгоно. 
      Хэрэглэгч нэвтэрсэн үед үндсэн хэрэгслийн (toolbar) мөрөнд 
      "Зураг нэмэх" гэсэн товчлуур байх ёстой бөгөөд энэ нь одоогийн нэвтэрсэн 
      хэрэглэгчийг апп руу зураг оруулах боломжийг олгодог. Зургийг амжилттай 
      байршуулсны дараа энэ нь хэрэглэгчийн зургийн хуудсан дээр автоматаар гарч ирэх эсвэл 
      хамгийн багадаа зургийг нэмсэн гэсэн тэмдэгтэй байх ёстой. Бид танд HTML ашиглан 
      файл байршуулах жишээг доорх зөвлөмж(hint) хэсэгт өгөх болно.

    </p>
    <p>
      URL дэх POST хүсэлтийг дэмжихийн тулд вэб серверийг өргөтгөх нь:
    <ul>
      <li><code>/photos/new</code> - Одоо байгаа хэрэглэгчийн зургийг байршуулна уу. 
        POST хүсэлтийн үндсэн хэсэг нь файл байх ёстой (доорх зөвлөмжийг (hints) үзнэ үү). Байршуулсан файлуудыг <code>images</code> ргийн санд өөрийн 
        үүсгэсэн өвөрмөц нэрээр байршуулах ёстой. Өвөрмөц нэрийг үүсгэсэн өгөгдөл болон нэвтэрсэн хэрэглэгчийн 
        ID-ийн хамт таны шинээр үүсгэсэн Фото объектод оруулах ёстой. Хэрэв POST хүсэлтэд файл байхгүй бол 400 
        гэсэн хариултын статусыг буцаана. Энэ талаар тусламж авахыг хүсвэл зөвлөмж (hints) хэсгээс үзнэ үү.
      </li>
    </ul>
    </p>
  </section>

  <section>
    <h3 class="left-border">Асуудал 4: Бүртгэл ба нууц үг (15 оноо)
    </h3>
    <p>
      Шинэ хэрэглэгчийн бүртгэл болон нууц үгийг дэмжихийн тулд <code>LoginRegister</code> харах бүрэлдэхүүн 
      (view component) хэсгийг сайжруулна уу. Шинэ хэрэглэгчийн бүртгэл болон нууц үгийг дэмжихийн 
      тулд LoginRegister харах бүрэлдэхүүн (view component) хэсгийг сайжруулна уу. Нууц үг 
      оруулах хэсэг нэмэхийн тулд нэвтрэх хэсгийг сунгана уу. Хэрэглэгчийн объектын бүх 
      хэсгийг дүүргэх боломжийг олгодог бүртгэлийн хэсгийг нэмнэ үү. Хэрэглэгч нууц үгээ бичдэг 
      гэсэн магадлалыг багасгахын тулд харагдац нь нууц үгийн хэсгийг дахин хуулбарлан агуулсан байх ёстой бөгөөд харагдац нь зөвхөн хэрэглэгчийн оруулсан нууц үгийн болон хуулбар хоёр талбар ижил байвал үүсгэнэ. Аюулгүй байдлын практик нь хэрэглэгчийн оруулсан нууц үг нь харагдах байдалд харагдахгүй байхыг шаарддаг. Бүртгэлийг хуудасны доод хэсэгт байрлах
      "Register Me" гэсэн товчлуураар идэвхжүүлнэ. Товчлуур дээр дарахад <b>specifically</b> яагаад ажиллахгүй байгааг тайлбарласан алдааг харуулах эсвэл амжилттай болсон тухай мэдээлэл ба бүртгэлийн 
      маягтын оруулах талбаруудыг арилгах шаардлагатай.
    </p>
    <p>
      Backend-ийн хувьд <code>User</code> ийн объектын схемийг нууц үг хадгалах <code>password</code> бүхий мөрийн талбарыг өргөтгө. 
      Энэ бол үнэхээр найдваргүй зүйл. Хэрэв та маш их найдваргүй зүйлийг хэрэгжүүлмээргүй бол доорх Нэмэлт кредитийг харна уу.
    </p>
    URL руу POST хүсэлтийг дэмжихийн тулд вэб серверийг өргөтгөх нь :
    <ul>
      <li>
        <code>/user</code> - Хэрэглэгч бүртгүүлэх боломжийг олгоно. Бүртгэлийн POST нь 
        дараах шинж чанаруудтай JSON кодлогдсон биеийг авдаг:
        (<code>login_name, password, first_name, last_name, location,
        description, occupation</code>). Нийтлэлийн хүсэлтийг зохицуулагч 
        нь шинэ <code>login_name</code> зааж өгсөн бөгөөд аль хэдийн байхгүй эсэхийг шалгах ёстой.
        <code>first_name</code>, <code>last_name</code>, болон
        <code>password</code> нь хоосон биш мөр байх ёстой (бусад талбарууд хоосон байж болно). 
        Хэрэв мэдээлэл хүчинтэй бол мэдээллийн санд шинэ хэрэглэгч бий болно. Хариултын хэсэг 
        нь таны вэб програмд ​​хэрэгтэй шинж чанарууд байх ёстой. Манай тестүүд <code>login_name</code> 
        шинж чанарыг агуулсан байхыг шаарддаг.
        Хэрэв алдаа гарсан бол хариу нь 400 статус 
        болон алдааг харуулсан мөрийг буцаана.
      </li>
    </ul>
    </p>
    <p>
      Нууц үгээр нэвтрэхийг дэмжихийн тулд <code>LoginRegister</code> харагдацыг сайжруулж, 
      <code>/admin/login</code> руу илгээх хүсэлтийн нэг хэсэг болгон шалгана уу.
    </p>
  </section>

  <section>
    <h3 class="left-border">Нэмэлт оноо №1: Давсалсан нууц үг (5 оноо)</h3>
    <p>
      Enhance the security of your password mechanism by implementing
      <i>salting</i>. The salting mechanism is described in the next few
      paragraphs. The problem with the clear text password mechanism we
      implemented for Problem 4 is if someone is able to read the database (for
      example, a rogue system administrator) they can easily retrieve all of the
      passwords for all users.
    </p>
    <p>
      A better approach is to apply a message digest function such as SHA-1 to
      each password, and store only the message digest in the database. SHA-1
      takes a string such as a password as input and produces a 40-character
      string of hex digits (called a <i>message digest</i>) as output. The
      output has two interesting properties: first, the digest provides a unique
      signature for the input string (there is no known way to produce two
      different strings with the same digest); second, given a message digest,
      there is no known way to produce a string that will generate that digest.
      When a user sets their password, you must invoke Node
      <a href="https://nodejs.org/api/crypto.html">crypto</a> package's
      <a href="https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm">
        <code>createHash</code></a> function to generate the SHA-1 digest
      corresponding to that password, and store only the digest in the
      database; once this is done you can discard the password. When a user
      enters a password to login, invoke createHash function to compute the
      digest, and compare that digest to what is stored in the database. With
      this approach, you can make sure that a user types the correct password
      when logging in, but if someone reads the digests from the database they
      cannot use that information to log in.
    </p>
    <p>
      However, the approach of the previous paragraph has one remaining flaw.
      Suppose an attacker gets a copy of the database containing the digests.
      Since the SHA-1 function is public, they can employ a fast <i>dictionary
        attack</i> to guess common passwords. To do this, the attacker takes each
      word from a dictionary and computes its digest using SHA-1. Then the
      attacker checks each digest in the database against the digests in the
      dictionary (this can be done very quickly by putting all of the dictionary
      digests in a hash table). If any user has chosen a simple dictionary word
      as their password, the attacker can guess it quickly.
    </p>
    <p>
      In order to make dictionary attacks more difficult, you must use password
      salting. When a user sets their password, compute a random number and
      concatenate it with the password before computing the SHA-1 digest (the
      crypto package
      <a href="https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback">
        <code>randomBytes</code></a> function with a length of 8 will return a
      suitable random number. The random number is called a <i>salt</i>. Then
      store both the salt and the digest in the database. When checking
      passwords during login, retrieve the salt from the database, concatenate
      it to the password typed by the user, and compute the digest of this
      string for comparison with the digest in the database. With this
      approach an attacker who has gained access to the login database cannot
      use the simple dictionary attack described above; the digest of a
      dictionary word would need to include the salt for a particular account,
      which means that the attacker would need to recompute all of the
      dictionary digests for every distinct account in the database. This
      makes dictionary attacks more expensive.
    </p>
    <p>
      To implement this, remove the <code>password</code> property from the User
      schema and replace it with two new string properties:
      <code>password_digest</code>
      and <code>salt</code>. Update the user register and login to use this
      mechanism.
    </p>
    <p>
      You should create and write your implementation in a node module file
      named <code>cs142password.js</code>. This module should export two
      functions:
    <pre>
/**
 * Return a salted and hashed password entry from a clear text password.
 * @param {string} clearTextPassword
 * @return {object} passwordEntry where passwordEntry is an object with two
 * string properties:
 *    salt - The salt used for the password.
 *    hash - The sha1 hash of the password and salt.
 */
function makePasswordEntry(clearTextPassword) {
</pre>
    and
    <pre>
/**
 * Return true if the specified clear text password and salt generates the
 * specified hash.
 * @param {string} hash
 * @param {string} salt
 * @param {string} clearTextPassword
 * @return {boolean}
 */
function doesPasswordMatch(hash, salt, clearTextPassword) {
</pre>
    We provide a Mocha test file <code>test/passwordApiTest.js</code> that
    tests this interface. Please make sure that you pass the tests within this
    file before submitting. You will need to change the
    <code>package.json</code>
    scripts test line to <code>mocha serverApiTest.js sessionInputApiTest.js
    passwordApiTest.js</code> so that running
    <code>npm test</code> runs these tests too. Changing this line also serves
    as indication that you've done this extra credit.

    You will also need to update the <code>loadDatabase.js</code> script to
    require <code>cs142password.js</code> and use it to generate the correct
    password properties in the new user objects that the script creates.
    </p>
  </section>

  <section>
    <h3 class="left-border">Extra Credit #2: Handle Browser Refresh (5
      points)</h3>
    <p>
      For simplicity in the regular parts of this assignment we allow you to
      keep the application's session state in JavaScript memory. Although this
      makes implementation easier, it means that a browser refresh causes the
      application to forget who is logged in.
    </p>
    <p>
      Extend your application to handle browser refresh like it did before you
      added the login session support. Your scheme should allow a user to do a
      browser refresh yet stay logged in. You are free to use whatever
      implementation techniques you want but they must:
    <ul>
      <li>Maintain backward compatibility with the other parts of this
        assignment, including the Mocha tests. </li>
      <li>Not mess up the security of the application.</li>
      <li>Work when submitted using the class assignment submission
        mechanism.</li>
    </ul>
    </p>
  </section>

  <section>
    <h3 class="left-border">Загварчлалын оноо (5 оноо)</h3>
    <p>
      Хэрэв таны асуудлын шийдэл нь MVC задаргаатай, 
      програм хангамжийн стекийн дүрмийг дагаж мөрддөг, ESLINT-ийн анхааруулгагүй 
      JavaScript-тэй байвал эдгээр оноог олгоно. Нэмж дурдахад, таны код, загварууд нь 
      цэвэрхэн, уншихад хялбар байх ёстой бөгөөд таны вэб хуудаснууд гадаад төрх, тав тухтай байдлын 
      хувьд дор хаяж "боломжийн сайхан" байх ёстой.
    </p>
  </section>

  <section>
    <h3 class="left-border">Шалгах(Testing)</h3>
    <p>
      testing-ийн хувьд бид:
    <ul>
      <li>Шинэ API дуудлагын зарим тестийн хамрах хүрээг хангадаг <code>test/sessionInputApiTest.js</code>
        нэртэй шинэ тест файлыг өгөх.</li>
      <li>Одоо байгаа <code>test/serverApiTest.js</code> шинэчилж хэрэглэгч рүү нэвтэрч, API дуудлага бүр 
        дээр сессийн мэдээллийг өгнө.</li>
    </ul>
    Бидний шинэчлэлт нь <code>serverApiTest.js</code> файлыг дарж бичих тул нэмэлт зээлийн нэг хэсэг 
    болгон Төсөл 6-д нэмсэн аливаа өөрчлөлтийг буцааж мэдээлэх шаардлагатай болно. Нөөц дамжуулахад 
    туслахын тулд (эсвэл та зүгээр л сонирхож байгаа бол) бид HTTP хүсэлтийн дуудлага бүрийн хүсэлтийн сонголтуудад 
    күүки толгойн түлхүүр-утгийн хосыг нэмсэн гэдгийг анхаарна уу. Дэлгэрэнгүйг тестийн файлаас үзнэ үү.
    </p>

    <p>
      <strong>Төсөл 6-д байгаа шиг, шалгалт өгөхөөсөө өмнө өгсөн шалгалтуудыг заавал давах 
        хэрэгтэй, учир нь таны үнэлгээний тодорхой хэсэг нь эдгээр шалгалтын хэд нь тэнцсэнээс 
        хамаарна.</strong>
    </p>

    <p>
      Туршилтууд нь мэдээллийн санд зөвхөн
      <code>loadDatabase.js</code> бъектуудыг агуулж байгааг анхаарна уу. Та тестийг эхлүүлэхийн өмнө <code>loadDatabase.js</code>
      ажиллуулах хэрэгтэй.
    </p>
    <p>
      Ямар нэгэн тест хийхээсээ өмнө <code>project7/test</code> directory-д
      <code>npm install</code> командыг бичиж <code>test/node_modules</code> шинэчлэгдсэн эсэхийг шалгах хэрэгтэй. 
      <div class=""></div>You
      Та 2 багцыг хуучирсан тухай анхааруулга авч магадгүй (жишээ нь
      <code>request</code> болон <code>har-validator</code>). Эдгээр нь бидний 
      туршилтад ашигладаг номын сангийн аль нэг нь засвар үйлчилгээ хийж байгаатай холбоотой 
      сэрэмжлүүлэг тул та эдгээрийг үл тоомсорлож болно. Та өмнөх шигээ <code>npm run test</code> командыг ашиглан 
      тестүүдийг ажиллуулж болно.
    </p>
  </section>

  <section>
    <h3 class="left-border">Hints</h3>
    Та одоо MongoDB мэдээллийн санг шинэчлэх код бичиж байгаа тул таны кодын алдаа 
    нь мэдээллийн сангийн агуулгыг гэмтээж болзошгүй юм. 
    <code>loadDatabase.js</code>  програмыг дахин ажиллуулснаар таны мэдээллийн санг цэвэр төлөвт(clean state) дахин 
    тохируулна. Туршилтууд таныг run бүрийн өмнө үүнийг хийсэн гэж үздэг.
    <h4>Асуудал 1    </h4>
    <p>
      Энэ асуудал нь таныг React програм болон вэб 
      серверт нэвтэрсэн хэрэглэгчийн тухай ойлголтыг авахыг шаарддаг. 
      Та өөрийн апп-аас вэб сервер рүү POST хүсэлт үүсгэхийн тулд загвараа 
      буулгаж, сессийн төлөвийг тохируулах хэрэгтэй. Сервер талын функцэд та үүний 
      эсрэг ажиллуулж болох тестүүд байдаг.
    </p>
    <p>
      Хэрэв та өөрийн <code>LoginRegister</code> cбүрэлдэхүүн хэсгийг бичиж, зургийн програмдаа нэмээд "/login-register" зам руу 
      чиглүүлсэн гэж үзвэл бид хэрэглэгч нэвтэрч ороогүй тохиолдолд тухайн харагдацыг харуулах хэрэгтэй. React
      React Router нь ашигтай үйлчилгээ үзүүлдэг. Дахин чиглүүлэлттэй ажиллах арга: <a
        href="https://v5.reactrouter.com/web/api/Redirect">React
        Router Redirect</a>. Хэрэв хэрэглэгч нэвтэрч ороогүй бол /login-register руу дахин чиглүүлэхийн тулд та маршрутаа өөрчилж болно. Жишээлбэл, хэрэв танд дараах маршрут байгаа бол:

    <div class="code">
      <pre>
&lt;Route path="/users/:id" component={UserDetail} /&gt;
</pre>
    </div>
    болон<code>this.userIsLoggedIn</code>, бүрэлдэхүүн хэсгийн өмчийг та дараах нөхцөлөөр багцалж
    /login-register руу шилжүүлж болно:
    <div class="code">
      <pre>
{
  this.userIsLoggedIn ?
    &lt;Route path="/users/:id" component={UserDetail} /&gt;
    :
    &lt;Redirect path="/users/:id" to="/login-register" /&gt;
}
</pre>
    </div>
    </p>
    <p>
      Асуудал 4 нь таны 1-р асуудалд зориулж бичсэн кодыг сайжруулдаг тул та Асуудлын 1-ийн шийдлийг бүтээхээсээ өмнө түүний хэрэгцээг ойлгохыг хүсч болно.
    </p>
    <h4>Асуудал 2 </h4>
    <p>
      Энэ асуудал нь 1-р асуудлыг шийдэхэд шаардлагатай 
      ихэнх зүйлийг дахин ашиглах болно. Нэг ялгаа нь comment 
      нь манай схемийн бие даасан объект биш юм. Тэдгээрийг 
      фото объект дотор суулгасан тул та объект үүсгэхийн оронд объектын 
      шинэчлэлт хийх шаардлагатай болно.
    </p>
    <h4>Асуудал 3 </h4>
    <p>
      Хөтөчүүд JavaScript кодыг дурын файлуудыг уншихыг 
      хүсэхгүй байгаа тул JavaScript фреймворкуудад файл 
      байршуулах нь хэцүү байдаг. Хөтөчүүд нь хэрэглэгчдэд 
      файлаа сонгоод агуулгыг нь вэб серверт илгээх 
      боломжийг олгодог интерфейсээр хангадаг. Бид энэ 
      механизмыг ашиглан манай зургийн аппликейшнд зураг 
      байршуулах боломжтой.

    </p>
    <p>
      React нь HTML-ийн <a <a href="https://reactjs.org/docs/uncontrolled-components.html#the-file-input-tag">
        input with type="file"
      </a>
      ашиглан хэрэглэгчдэд файл сонгох боломжийг бий болгоно. Дараах мөрийг таны зургийн аппликейшн дээр нэмсэн
    <pre>
&lt;input type="file" accept="image/*" ref={(domFileRef) => { this.uploadInput = domFileRef; }} />
</pre>
    нь хөтөчийг(Browser) "Choose File" гэсэн хэсэгтэй товчлуурыг нэмж оруулах бөгөөд хэрэглэгч дотоод файлаа сонгох боломжтой. Хэрэглэгч файлыг сонгох үед 
    <code>this.uploadInput</code> нь DOM файлыг авч вэб сервер рүү илгээх боломжтой оролтын элементээс
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileList">
      DOM FileList
    </a>
    агуулна.

    Та мөн доор тайлбарласны дагуу фото файлыг серверт 
    илгээхийн тулд хэрэглэгч дарах товчлууртай байх шаардлагатай.

    </p>
    <p>
      Сонгосон файлыг DOM-д оруулсны дараа бид үүнийг
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData">
        DOM form
      </a>
      нэмж, вэб сервер рүү POST хүсэлтээр илгээх боломжтой. Дараах код нь үүнийг хийх жишээг өгдөг. 
      Энэ нь оролтын элементийн DOM файлын жагсаалтыг <code>this.uploadInput</code>-д оруулсан гэж үздэг.
    <pre>
/**
 * Called when user presses the update button.
 */
handleUploadButtonClicked = (e) => {
  e.preventDefault();
  if (this.uploadInput.files.length > 0) {
    // Create a DOM form and add the file to it under the name uploadedphoto
    const domForm = new FormData();
    domForm.append('uploadedphoto', this.uploadInput.files[0]);
    axios.post('/photos/new', domForm)
      .then((res) => {
        console.log(res);
      })
      .catch(err => console.log(`POST ERR: ${err}`));
  }
}
</pre>
    </p>
    <p>
      Body-parser ашиглан экспресс нь файл агуулсан маягттай POST хүсэлтийг зохицуулах боломжгүй боловч 
      <a
        href="https://www.npmjs.com/package/multer#readme"><code>multer</code></a>  нэртэй дунд программаар хийх боломжтой.
        Мультерийн  require-ийн дараа дараах мөрийг оруулна уу:
    <pre>
const processFormBody = multer({storage: multer.memoryStorage()}).single('uploadedphoto');
</pre>
    <code>processFormBody</code> нь бидний
    <code>/photos/new</code> -д зориулсан шуудангийн хүсэлтийг зохицуулагчдаа ашиглаж болох функц юм.
    <code>processFormBody</code> нь "uploadedphoto" нэртэй талбарын маягтыг харж, тэндээс файлыг татаж аваад хүсэлтийн объект дээр
    <code>file</code> нэртэй өмчийн мэдээллийг байрлуулна. Дараах код нь таны шуудангийн хүсэлтийн 
    зохицуулагч дээр үүнийг хэрхэн дуудах талаар санааг өгнө:
    <pre>
processFormBody(request, response, function (err) {
  if (err || !request.file) {
      // XXX -  Insert error handling code here.
      return;
  }

  // request.file has the following properties of interest:
  //   fieldname    - Should be 'uploadedphoto' since that is what we sent
  //   originalname - The name of the file the user uploaded
  //   mimetype     - The mimetype of the image (e.g., 'image/jpeg',
  //                  'image/png')
  //   buffer       - A node Buffer containing the contents of the file
  //   size         - The size of the file in bytes

  // XXX - Do some validation here.

  // We need to create the file in the directory "images" under an unique name.
  // We make the original file name unique by adding a unique prefix with a
  // timestamp.
  const timestamp = new Date().valueOf();
  const filename = 'U' +  String(timestamp) + request.file.originalname;

  fs.writeFile("./images/" + filename, request.file.buffer, function (err) {
    // XXX - Once you have the file written into your images directory under the
    // name filename you can create the Photo object in the database
  });
});
</pre>
    </p>
    <p>
      Дээрх кодын фрагмент нь Node.js багц 
      <a href="https://nodejs.org/api/fs.html"><code>fs</code></a>-г ашигладаг тул та үүнийг webServer.js-дээ оруулах хэрэгтэй болно:
    <pre>const fs = require("fs");</pre>
    </p>
    <h4>Асуудал 4
    </h4>
    <p>
      Энэ асуудал нь өмнөх асуудлуудад шаардлагатай арга техникийг нэгтгэсэн болно.
    </p>
  </section>

  <section>

    <h3 class="left-border">Хүлээлгэн өгөх үр дүн</h3>
    <p>
      <code>project7</code> илгээхдээ стандарт <a href="submit.html">submission mechanism</a>-ийг ашиглана. Please clean up your project directory
      Илгээх зааварт заасны дагуу илгээхээсээ өмнө төслийн лавлахаа (directory) цэвэрлэнэ үү. Нэмж дурдахад, зургийн лавлахдаа байршуулсан бүх зургийг устгана уу. Хэрэв та "Зөвлөгөө (Hint)" хэсэгт байршуулсан зургуудыг нэрлэх дүрмийг баримталсан бол
      <code>rm -f images/U*</code> командыг ашиглан <code>project7</code>-аас устгаж болно.
    </p>

  </section>

</div>
</main>

    

<footer>
    <div class="container text-center">
        <small class="text-muted">
            Загварыг Рэймонд Луонг Стэнфордын их сургуулийн CS142 хичээлд зориулан бүтээв.
            <br>
            <a href="http://getbootstrap.com/" target="_blank">Bootstrap</a> болон <a href="https://jekyllrb.com" target="_blank">Jekyll</a> багажаар <a href="website.html"><strong>бүтээгдсэн.</strong></a>
        </small>
      </div>
</footer>


  </body>

</html>
